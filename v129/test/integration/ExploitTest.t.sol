//SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {Test, console} from "forge-std/Test.sol";
import {GiveUp129} from "../../src/GiveUp_129.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {DeployGiveUp129} from "../../script/DeployGiveUp129.s.sol";
import "../unit/Input_Params.sol";
import "../../src/GlobalVariables_12x.sol";
import {CommunityToken} from "../mock/CTK.sol";
import {RottenToken} from "../mock/ROTTEN.sol";
import {AnyToken} from "../mock/ANY.sol";
import {CreateOrUpdate, DonateOrVote, WithdrawOrRefund, PaidoutOrDelete, Util} from "../../script/Interactions.s.sol";

/**
 * Notes in this test:
 * MAX_RULES is the campaign Id of the latest campaign
 * SEND_VALUE is the target amount of native token (e.g. ETH) of test campaign
 * SEND_TOKEN_AMT is the target amount of white list token (e.g. CTK) of test campaign
 */
contract GiveUp129ExploitTest is Test {
    GiveUp129 giveUp;
    CommunityToken ctk;
    RottenToken rotten;
    AnyToken any;

    function setUp() external {
        uint256 platformFee = 0; // if pass these params from outside will cost gas
        string memory nativeTokenSymbol = "ETH";
        DeployGiveUp129 deployGiveUp129 = new DeployGiveUp129();
        (giveUp, ctk, rotten, any,,) = deployGiveUp129.run(platformFee, nativeTokenSymbol);
        vm.deal(RAISER1, STARTING_USER_BALANCE);
        vm.deal(RAISER2, STARTING_USER_BALANCE);
        vm.deal(BACKER1, STARTING_USER_BALANCE);
        vm.deal(BACKER2, STARTING_USER_BALANCE);
        console.log("address of giveUp, address of this GiveUp129Test: ", address(giveUp), address(this));
    }

    /**
     * donation campaign type, no Alchemist
     */
    modifier campaign_100_0_Created() {
        CreateCampaignInput memory c_input = initializeCampaignData_100_0(); // set target fund is 0.1 ether (SEND_VALUE)
        vm.prank(RAISER1); // create a normal campaign via RAISER1, not via address(this)
        uint256 returnCId = giveUp.createCampaign(
            c_input.haveFundTarget,
            c_input.content,
            c_input.options,
            c_input.timeline,
            c_input.group,
            c_input.deList,
            c_input.fund,
            c_input.pctForBackers,
            ALCHEMIST1
        );
        assertEq(returnCId, giveUp.nextCId() - 1);
        _;
    }

    /**
     * Non Profit Campaign Type + have Alchemist
     */
    modifier campaign_0_90_Created() {
        vm.prank(RAISER1);
        CreateCampaignInput memory c_input = initializeCreateCampaignData(0, 90);
        giveUp.createCampaign(
            c_input.haveFundTarget,
            c_input.content,
            c_input.options,
            c_input.timeline,
            c_input.group,
            c_input.deList,
            c_input.fund,
            c_input.pctForBackers,
            ALCHEMIST1
        );
        _;
    }

    modifier initWLToken() {
        vm.startPrank(giveUp.contractOwner());
        giveUp.addWhiteListToken(address(ctk), "firstToken");
        giveUp.addWhiteListToken(address(rotten), "rotten");
        assert(giveUp.getIsTokenWhitelisted(address(ctk)));
        assert(giveUp.getIsTokenWhitelisted(address(rotten)));
        vm.stopPrank();
        _;
    }

    function getLatestCampaign() public view returns (CampaignNoBacker memory) {
        CampaignNoBacker[] memory campaignsNoBacker = giveUp.getCampaigns();
        CampaignNoBacker memory campaign = campaignsNoBacker[(giveUp.nextCId() - 1) - MAX_RULES]; // cause getCampaigns() compressed and reindexed
        return campaign;
    }

    function donateToCampaign(uint256 _amount, uint256 _campaignId, uint256 _option, uint256 _feedback)
        public
        returns (bool)
    {
        bool result = giveUp.donateToCampaign{value: _amount}(_campaignId, _option, _feedback);
        return result;
    }

    /**
     * NOTE: access control problem: "contract impersonation" or "contract hijacking" attack
     * An attacker could potentially exploit this vulnerability by crafting a transaction that include malicious code to impersonate the giveUp contract itself then trigger transfer fund.
     * https://g.co/gemini/share/11f46baef05d
     *
     */
    function testExploit_1() public campaign_100_0_Created {
        vm.warp(block.timestamp + 86400 * 4); // set proper timeframe to donate when campaign start
        donateToCampaign(SEND_VALUE * 2, MAX_RULES, 0, 0);
        (bool success,) = RAISER1.call{value: SEND_VALUE * 2}("");
        console.log("success", success); // can not withdraw from giveUp contract directly, RAISER1 self transfer to himself not related to giveUp !!!
        assertEq(success, true);
        assertEq(address(giveUp).balance, SEND_VALUE * 2); // giveUp contract balance still intact
        vm.startPrank((address(giveUp))); // BUT if hacker deploy an instance using deployed address of giveUp
        (bool success1,) = RAISER1.call{value: SEND_VALUE * 2}("");
        assertEq(success1, true); // RAISER1 can send native token in hacker malicious contract !!!
        vm.stopPrank();
        console.log(success, " contract balance = ", address(giveUp).balance);
        console.log("RAISER1.balance", RAISER1.balance);
        assertEq(address(giveUp).balance, 0);
    }
    // uninitialized variable can be exploited ?
}
